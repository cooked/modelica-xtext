/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package sc.modelica.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sc.modelica.xtext.modelicaMo.AlgorithmSection;
import sc.modelica.xtext.modelicaMo.Annotation;
import sc.modelica.xtext.modelicaMo.AnnotationCode;
import sc.modelica.xtext.modelicaMo.AnnotationDocumentation;
import sc.modelica.xtext.modelicaMo.AnnotationExperiment;
import sc.modelica.xtext.modelicaMo.ArgumentList;
import sc.modelica.xtext.modelicaMo.ArithmeticExpression;
import sc.modelica.xtext.modelicaMo.ArithmeticExpression2;
import sc.modelica.xtext.modelicaMo.ArraySubscripts;
import sc.modelica.xtext.modelicaMo.Assert;
import sc.modelica.xtext.modelicaMo.Bitmap;
import sc.modelica.xtext.modelicaMo.Choices;
import sc.modelica.xtext.modelicaMo.ClassDefinition;
import sc.modelica.xtext.modelicaMo.ClassModification;
import sc.modelica.xtext.modelicaMo.ClassPrefixes;
import sc.modelica.xtext.modelicaMo.Color;
import sc.modelica.xtext.modelicaMo.Comment;
import sc.modelica.xtext.modelicaMo.ComponentClause;
import sc.modelica.xtext.modelicaMo.ComponentClause1;
import sc.modelica.xtext.modelicaMo.ComponentDeclaration;
import sc.modelica.xtext.modelicaMo.ComponentList;
import sc.modelica.xtext.modelicaMo.ComponentReference;
import sc.modelica.xtext.modelicaMo.Composition;
import sc.modelica.xtext.modelicaMo.ConditionAttribute;
import sc.modelica.xtext.modelicaMo.ConnectClause;
import sc.modelica.xtext.modelicaMo.ConstrainingClause;
import sc.modelica.xtext.modelicaMo.CoordinateSpecification;
import sc.modelica.xtext.modelicaMo.Declaration;
import sc.modelica.xtext.modelicaMo.DefComponentName;
import sc.modelica.xtext.modelicaMo.DerClassSpecifier;
import sc.modelica.xtext.modelicaMo.Dialog;
import sc.modelica.xtext.modelicaMo.Element;
import sc.modelica.xtext.modelicaMo.ElementList;
import sc.modelica.xtext.modelicaMo.ElementModification;
import sc.modelica.xtext.modelicaMo.ElementModificationOrReplaceable;
import sc.modelica.xtext.modelicaMo.ElementRedeclaration;
import sc.modelica.xtext.modelicaMo.ElementReplaceable;
import sc.modelica.xtext.modelicaMo.Ellipse;
import sc.modelica.xtext.modelicaMo.Enable;
import sc.modelica.xtext.modelicaMo.EnumList;
import sc.modelica.xtext.modelicaMo.EnumerationLiteral;
import sc.modelica.xtext.modelicaMo.Equation;
import sc.modelica.xtext.modelicaMo.EquationFor;
import sc.modelica.xtext.modelicaMo.EquationIf;
import sc.modelica.xtext.modelicaMo.EquationSection;
import sc.modelica.xtext.modelicaMo.EquationWhen;
import sc.modelica.xtext.modelicaMo.ExperimentOption;
import sc.modelica.xtext.modelicaMo.ExprExpressionList;
import sc.modelica.xtext.modelicaMo.Expression;
import sc.modelica.xtext.modelicaMo.ExtendClause;
import sc.modelica.xtext.modelicaMo.Extent;
import sc.modelica.xtext.modelicaMo.Factor;
import sc.modelica.xtext.modelicaMo.ForIndex;
import sc.modelica.xtext.modelicaMo.ForIndices;
import sc.modelica.xtext.modelicaMo.FunctionArgument;
import sc.modelica.xtext.modelicaMo.FunctionArguments;
import sc.modelica.xtext.modelicaMo.FunctionCallArgs;
import sc.modelica.xtext.modelicaMo.GraphicalPrimitiveArgs;
import sc.modelica.xtext.modelicaMo.Graphics;
import sc.modelica.xtext.modelicaMo.Grid;
import sc.modelica.xtext.modelicaMo.Group;
import sc.modelica.xtext.modelicaMo.ImportClause;
import sc.modelica.xtext.modelicaMo.ImportList;
import sc.modelica.xtext.modelicaMo.InitialScale;
import sc.modelica.xtext.modelicaMo.LayerDiagram;
import sc.modelica.xtext.modelicaMo.LayerIcon;
import sc.modelica.xtext.modelicaMo.Line;
import sc.modelica.xtext.modelicaMo.LogicalExpression;
import sc.modelica.xtext.modelicaMo.LogicalTerm;
import sc.modelica.xtext.modelicaMo.LongClassSpecifier;
import sc.modelica.xtext.modelicaMo.ModelicaMoPackage;
import sc.modelica.xtext.modelicaMo.Modification;
import sc.modelica.xtext.modelicaMo.Name;
import sc.modelica.xtext.modelicaMo.NamedArgument;
import sc.modelica.xtext.modelicaMo.NamedArguments;
import sc.modelica.xtext.modelicaMo.Origin;
import sc.modelica.xtext.modelicaMo.OutputExpresionList;
import sc.modelica.xtext.modelicaMo.Placement;
import sc.modelica.xtext.modelicaMo.Point;
import sc.modelica.xtext.modelicaMo.Polygon;
import sc.modelica.xtext.modelicaMo.PreserveAR;
import sc.modelica.xtext.modelicaMo.Primary;
import sc.modelica.xtext.modelicaMo.Program;
import sc.modelica.xtext.modelicaMo.Radius;
import sc.modelica.xtext.modelicaMo.Rectangle;
import sc.modelica.xtext.modelicaMo.Relation;
import sc.modelica.xtext.modelicaMo.Rotation;
import sc.modelica.xtext.modelicaMo.ShortClassDefinition;
import sc.modelica.xtext.modelicaMo.ShortClassSpecifier;
import sc.modelica.xtext.modelicaMo.Smooth;
import sc.modelica.xtext.modelicaMo.Statement;
import sc.modelica.xtext.modelicaMo.StatementFor;
import sc.modelica.xtext.modelicaMo.StatementIf;
import sc.modelica.xtext.modelicaMo.StatementWhen;
import sc.modelica.xtext.modelicaMo.StatementWhile;
import sc.modelica.xtext.modelicaMo.StringComment;
import sc.modelica.xtext.modelicaMo.Subscript;
import sc.modelica.xtext.modelicaMo.Tab;
import sc.modelica.xtext.modelicaMo.Term;
import sc.modelica.xtext.modelicaMo.Text;
import sc.modelica.xtext.modelicaMo.Thickness;
import sc.modelica.xtext.modelicaMo.Transformation;
import sc.modelica.xtext.modelicaMo.TypePrefix;
import sc.modelica.xtext.modelicaMo.TypeSpecifier;
import sc.modelica.xtext.modelicaMo.Visible;
import sc.modelica.xtext.services.ModelicaMoGrammarAccess;

@SuppressWarnings("all")
public class ModelicaMoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ModelicaMoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelicaMoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelicaMoPackage.ALGORITHM_SECTION:
				sequence_AlgorithmSection(context, (AlgorithmSection) semanticObject); 
				return; 
			case ModelicaMoPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case ModelicaMoPackage.ANNOTATION_CODE:
				sequence_AnnotationCode(context, (AnnotationCode) semanticObject); 
				return; 
			case ModelicaMoPackage.ANNOTATION_DOCUMENTATION:
				sequence_AnnotationDocumentation(context, (AnnotationDocumentation) semanticObject); 
				return; 
			case ModelicaMoPackage.ANNOTATION_EXPERIMENT:
				sequence_AnnotationExperiment(context, (AnnotationExperiment) semanticObject); 
				return; 
			case ModelicaMoPackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case ModelicaMoPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case ModelicaMoPackage.ARITHMETIC_EXPRESSION2:
				sequence_ArithmeticExpression2(context, (ArithmeticExpression2) semanticObject); 
				return; 
			case ModelicaMoPackage.ARRAY_SUBSCRIPTS:
				sequence_ArraySubscripts(context, (ArraySubscripts) semanticObject); 
				return; 
			case ModelicaMoPackage.ASSERT:
				sequence_Assert(context, (Assert) semanticObject); 
				return; 
			case ModelicaMoPackage.BITMAP:
				sequence_Bitmap(context, (Bitmap) semanticObject); 
				return; 
			case ModelicaMoPackage.CHOICES:
				sequence_Choices(context, (Choices) semanticObject); 
				return; 
			case ModelicaMoPackage.CLASS_DEFINITION:
				sequence_ClassDefinition(context, (ClassDefinition) semanticObject); 
				return; 
			case ModelicaMoPackage.CLASS_MODIFICATION:
				sequence_ClassModification(context, (ClassModification) semanticObject); 
				return; 
			case ModelicaMoPackage.CLASS_PREFIXES:
				sequence_ClassPrefixes(context, (ClassPrefixes) semanticObject); 
				return; 
			case ModelicaMoPackage.COLOR:
				sequence_Color(context, (Color) semanticObject); 
				return; 
			case ModelicaMoPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case ModelicaMoPackage.COMPONENT_CLAUSE:
				sequence_ComponentClause(context, (ComponentClause) semanticObject); 
				return; 
			case ModelicaMoPackage.COMPONENT_CLAUSE1:
				sequence_ComponentClause1(context, (ComponentClause1) semanticObject); 
				return; 
			case ModelicaMoPackage.COMPONENT_DECLARATION:
				sequence_ComponentDeclaration(context, (ComponentDeclaration) semanticObject); 
				return; 
			case ModelicaMoPackage.COMPONENT_LIST:
				sequence_ComponentList(context, (ComponentList) semanticObject); 
				return; 
			case ModelicaMoPackage.COMPONENT_REFERENCE:
				sequence_ComponentReference(context, (ComponentReference) semanticObject); 
				return; 
			case ModelicaMoPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case ModelicaMoPackage.CONDITION_ATTRIBUTE:
				sequence_ConditionAttribute(context, (ConditionAttribute) semanticObject); 
				return; 
			case ModelicaMoPackage.CONNECT_CLAUSE:
				sequence_ConnectClause(context, (ConnectClause) semanticObject); 
				return; 
			case ModelicaMoPackage.CONSTRAINING_CLAUSE:
				sequence_ConstrainingClause(context, (ConstrainingClause) semanticObject); 
				return; 
			case ModelicaMoPackage.COORDINATE_SPECIFICATION:
				sequence_CoordinateSpecification(context, (CoordinateSpecification) semanticObject); 
				return; 
			case ModelicaMoPackage.DECLARATION:
				if (rule == grammarAccess.getComponentDeclaration1Rule()) {
					sequence_ComponentDeclaration1_Declaration(context, (Declaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()) {
					sequence_Declaration(context, (Declaration) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.DEF_COMPONENT_NAME:
				sequence_DefComponentName(context, (DefComponentName) semanticObject); 
				return; 
			case ModelicaMoPackage.DER_CLASS_SPECIFIER:
				sequence_DerClassSpecifier(context, (DerClassSpecifier) semanticObject); 
				return; 
			case ModelicaMoPackage.DIALOG:
				sequence_Dialog(context, (Dialog) semanticObject); 
				return; 
			case ModelicaMoPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case ModelicaMoPackage.ELEMENT_LIST:
				sequence_ElementList(context, (ElementList) semanticObject); 
				return; 
			case ModelicaMoPackage.ELEMENT_MODIFICATION:
				sequence_ElementModification(context, (ElementModification) semanticObject); 
				return; 
			case ModelicaMoPackage.ELEMENT_MODIFICATION_OR_REPLACEABLE:
				sequence_ElementModificationOrReplaceable(context, (ElementModificationOrReplaceable) semanticObject); 
				return; 
			case ModelicaMoPackage.ELEMENT_REDECLARATION:
				sequence_ElementRedeclaration(context, (ElementRedeclaration) semanticObject); 
				return; 
			case ModelicaMoPackage.ELEMENT_REPLACEABLE:
				sequence_ElementReplaceable(context, (ElementReplaceable) semanticObject); 
				return; 
			case ModelicaMoPackage.ELLIPSE:
				sequence_Ellipse(context, (Ellipse) semanticObject); 
				return; 
			case ModelicaMoPackage.ENABLE:
				sequence_Enable(context, (Enable) semanticObject); 
				return; 
			case ModelicaMoPackage.ENUM_LIST:
				sequence_EnumList(context, (EnumList) semanticObject); 
				return; 
			case ModelicaMoPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case ModelicaMoPackage.EQUATION:
				sequence_Equation(context, (Equation) semanticObject); 
				return; 
			case ModelicaMoPackage.EQUATION_FOR:
				if (rule == grammarAccess.getEquationForRule()) {
					sequence_EquationFor(context, (EquationFor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEquationRule()) {
					sequence_Equation_EquationFor(context, (EquationFor) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.EQUATION_IF:
				if (rule == grammarAccess.getEquationIfRule()) {
					sequence_EquationIf(context, (EquationIf) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEquationRule()) {
					sequence_Equation_EquationIf(context, (EquationIf) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.EQUATION_SECTION:
				sequence_EquationSection(context, (EquationSection) semanticObject); 
				return; 
			case ModelicaMoPackage.EQUATION_WHEN:
				if (rule == grammarAccess.getEquationWhenRule()) {
					sequence_EquationWhen(context, (EquationWhen) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEquationRule()) {
					sequence_Equation_EquationWhen(context, (EquationWhen) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.EXPERIMENT_OPTION:
				sequence_ExperimentOption(context, (ExperimentOption) semanticObject); 
				return; 
			case ModelicaMoPackage.EXPR_EXPRESSION_LIST:
				sequence_ExprExpressionList(context, (ExprExpressionList) semanticObject); 
				return; 
			case ModelicaMoPackage.EXPRESSION:
				if (rule == grammarAccess.getLogicalExpressionRule()
						|| action == grammarAccess.getLogicalExpressionAccess().getLogicalExpressionLeftAction_1_0()
						|| rule == grammarAccess.getLogicalTermRule()
						|| action == grammarAccess.getLogicalTermAccess().getLogicalTermLeftAction_1_0()
						|| rule == grammarAccess.getLogicalFactorRule()
						|| rule == grammarAccess.getRelationRule()
						|| action == grammarAccess.getRelationAccess().getRelationLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| action == grammarAccess.getArithmeticExpressionAccess().getArithmeticExpressionLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticExpressionUnaryRule()) {
					sequence_ArithmeticExpressionUnary_Primary(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEquationRule()) {
					sequence_Equation_SimpleExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getSubscriptRule()) {
					sequence_Expression_SimpleExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArithmeticExpression2Rule()
						|| action == grammarAccess.getArithmeticExpression2Access().getArithmeticExpression2LeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getTermLeftAction_1_0()
						|| rule == grammarAccess.getFactorRule()
						|| action == grammarAccess.getFactorAccess().getFactorLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_Primary(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleExpressionRule()) {
					sequence_SimpleExpression(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.EXTEND_CLAUSE:
				sequence_ExtendClause(context, (ExtendClause) semanticObject); 
				return; 
			case ModelicaMoPackage.EXTENT:
				sequence_Extent(context, (Extent) semanticObject); 
				return; 
			case ModelicaMoPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case ModelicaMoPackage.FOR_INDEX:
				sequence_ForIndex(context, (ForIndex) semanticObject); 
				return; 
			case ModelicaMoPackage.FOR_INDICES:
				sequence_ForIndices(context, (ForIndices) semanticObject); 
				return; 
			case ModelicaMoPackage.FUNCTION_ARGUMENT:
				sequence_FunctionArgument(context, (FunctionArgument) semanticObject); 
				return; 
			case ModelicaMoPackage.FUNCTION_ARGUMENTS:
				sequence_FunctionArguments(context, (FunctionArguments) semanticObject); 
				return; 
			case ModelicaMoPackage.FUNCTION_CALL_ARGS:
				sequence_FunctionCallArgs(context, (FunctionCallArgs) semanticObject); 
				return; 
			case ModelicaMoPackage.GRAPHICAL_PRIMITIVE_ARGS:
				sequence_GraphicalPrimitiveArgs(context, (GraphicalPrimitiveArgs) semanticObject); 
				return; 
			case ModelicaMoPackage.GRAPHICS:
				sequence_Graphics(context, (Graphics) semanticObject); 
				return; 
			case ModelicaMoPackage.GRID:
				sequence_Grid(context, (Grid) semanticObject); 
				return; 
			case ModelicaMoPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case ModelicaMoPackage.IMPORT_CLAUSE:
				sequence_ImportClause(context, (ImportClause) semanticObject); 
				return; 
			case ModelicaMoPackage.IMPORT_LIST:
				sequence_ImportList(context, (ImportList) semanticObject); 
				return; 
			case ModelicaMoPackage.INITIAL_SCALE:
				sequence_InitialScale(context, (InitialScale) semanticObject); 
				return; 
			case ModelicaMoPackage.LAYER_DIAGRAM:
				sequence_LayerDiagram(context, (LayerDiagram) semanticObject); 
				return; 
			case ModelicaMoPackage.LAYER_ICON:
				sequence_LayerIcon(context, (LayerIcon) semanticObject); 
				return; 
			case ModelicaMoPackage.LINE:
				sequence_Line(context, (Line) semanticObject); 
				return; 
			case ModelicaMoPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case ModelicaMoPackage.LOGICAL_TERM:
				sequence_LogicalTerm(context, (LogicalTerm) semanticObject); 
				return; 
			case ModelicaMoPackage.LONG_CLASS_SPECIFIER:
				sequence_LongClassSpecifier(context, (LongClassSpecifier) semanticObject); 
				return; 
			case ModelicaMoPackage.MODIFICATION:
				sequence_Modification(context, (Modification) semanticObject); 
				return; 
			case ModelicaMoPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case ModelicaMoPackage.NAMED_ARGUMENT:
				sequence_NamedArgument(context, (NamedArgument) semanticObject); 
				return; 
			case ModelicaMoPackage.NAMED_ARGUMENTS:
				sequence_NamedArguments(context, (NamedArguments) semanticObject); 
				return; 
			case ModelicaMoPackage.ORIGIN:
				sequence_Origin(context, (Origin) semanticObject); 
				return; 
			case ModelicaMoPackage.OUTPUT_EXPRESION_LIST:
				sequence_OutputExpressionList(context, (OutputExpresionList) semanticObject); 
				return; 
			case ModelicaMoPackage.PLACEMENT:
				sequence_Placement(context, (Placement) semanticObject); 
				return; 
			case ModelicaMoPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case ModelicaMoPackage.POLYGON:
				sequence_Polygon(context, (Polygon) semanticObject); 
				return; 
			case ModelicaMoPackage.PRESERVE_AR:
				sequence_PreserveAR(context, (PreserveAR) semanticObject); 
				return; 
			case ModelicaMoPackage.PRIMARY:
				sequence_Primary(context, (Primary) semanticObject); 
				return; 
			case ModelicaMoPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ModelicaMoPackage.RADIUS:
				sequence_Radius(context, (Radius) semanticObject); 
				return; 
			case ModelicaMoPackage.RECTANGLE:
				sequence_Rectangle(context, (Rectangle) semanticObject); 
				return; 
			case ModelicaMoPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case ModelicaMoPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case ModelicaMoPackage.SHORT_CLASS_DEFINITION:
				sequence_ShortClassDefinition(context, (ShortClassDefinition) semanticObject); 
				return; 
			case ModelicaMoPackage.SHORT_CLASS_SPECIFIER:
				sequence_ShortClassSpecifier(context, (ShortClassSpecifier) semanticObject); 
				return; 
			case ModelicaMoPackage.SMOOTH:
				sequence_Smooth(context, (Smooth) semanticObject); 
				return; 
			case ModelicaMoPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case ModelicaMoPackage.STATEMENT_FOR:
				if (rule == grammarAccess.getStatementForRule()) {
					sequence_StatementFor(context, (StatementFor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement_StatementFor(context, (StatementFor) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.STATEMENT_IF:
				if (rule == grammarAccess.getStatementIfRule()) {
					sequence_StatementIf(context, (StatementIf) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement_StatementIf(context, (StatementIf) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.STATEMENT_WHEN:
				if (rule == grammarAccess.getStatementWhenRule()) {
					sequence_StatementWhen(context, (StatementWhen) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement_StatementWhen(context, (StatementWhen) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.STATEMENT_WHILE:
				if (rule == grammarAccess.getStatementWhileRule()) {
					sequence_StatementWhile(context, (StatementWhile) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement_StatementWhile(context, (StatementWhile) semanticObject); 
					return; 
				}
				else break;
			case ModelicaMoPackage.STRING_COMMENT:
				sequence_StringComment(context, (StringComment) semanticObject); 
				return; 
			case ModelicaMoPackage.SUBSCRIPT:
				sequence_Subscript(context, (Subscript) semanticObject); 
				return; 
			case ModelicaMoPackage.TAB:
				sequence_Tab(context, (Tab) semanticObject); 
				return; 
			case ModelicaMoPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case ModelicaMoPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case ModelicaMoPackage.THICKNESS:
				sequence_Thickness(context, (Thickness) semanticObject); 
				return; 
			case ModelicaMoPackage.TRANSFORMATION:
				sequence_Transformation(context, (Transformation) semanticObject); 
				return; 
			case ModelicaMoPackage.TYPE_PREFIX:
				sequence_TypePrefix(context, (TypePrefix) semanticObject); 
				return; 
			case ModelicaMoPackage.TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (TypeSpecifier) semanticObject); 
				return; 
			case ModelicaMoPackage.VISIBLE:
				sequence_Visible(context, (Visible) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AlgorithmSection returns AlgorithmSection
	 *
	 * Constraint:
	 *     (initial?='initial'? algorithm='algorithm' statements+=Statement*)
	 */
	protected void sequence_AlgorithmSection(ISerializationContext context, AlgorithmSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns AnnotationCode
	 *     AnnotationCode returns AnnotationCode
	 *
	 * Constraint:
	 *     (flag=CodeGenerationFlag (value='true' | value='false'))
	 */
	protected void sequence_AnnotationCode(ISerializationContext context, AnnotationCode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns AnnotationDocumentation
	 *     AnnotationDocumentation returns AnnotationDocumentation
	 *
	 * Constraint:
	 *     (value=STRING rev=STRING?)
	 */
	protected void sequence_AnnotationDocumentation(ISerializationContext context, AnnotationDocumentation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns AnnotationExperiment
	 *     AnnotationExperiment returns AnnotationExperiment
	 *
	 * Constraint:
	 *     (options+=ExperimentOption options+=ExperimentOption*)?
	 */
	protected void sequence_AnnotationExperiment(ISerializationContext context, AnnotationExperiment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (args+=AnnotationArg args+=AnnotationArg*)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentList returns ArgumentList
	 *
	 * Constraint:
	 *     (arguments+=Argument arguments+=Argument*)
	 */
	protected void sequence_ArgumentList(ISerializationContext context, ArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression2 returns ArithmeticExpression2
	 *
	 * Constraint:
	 *     (left=ArithmeticExpression2_ArithmeticExpression2_1_0 right=ArithmeticExpression2)
	 */
	protected void sequence_ArithmeticExpression2(ISerializationContext context, ArithmeticExpression2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION2__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION2__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION2__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION2__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpression2Access().getArithmeticExpression2LeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticExpression2Access().getRightArithmeticExpression2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns Expression
	 *     LogicalExpression.LogicalExpression_1_0 returns Expression
	 *     LogicalTerm returns Expression
	 *     LogicalTerm.LogicalTerm_1_0 returns Expression
	 *     LogicalFactor returns Expression
	 *     Relation returns Expression
	 *     Relation.Relation_1_0 returns Expression
	 *     ArithmeticExpression returns Expression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns Expression
	 *     ArithmeticExpressionUnary returns Expression
	 *
	 * Constraint:
	 *     (exp=Term | (list+=ExprExpressionList list+=ExprExpressionList*) | fa=FunctionArguments)
	 */
	protected void sequence_ArithmeticExpressionUnary_Primary(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns ArithmeticExpression
	 *     LogicalExpression.LogicalExpression_1_0 returns ArithmeticExpression
	 *     LogicalTerm returns ArithmeticExpression
	 *     LogicalTerm.LogicalTerm_1_0 returns ArithmeticExpression
	 *     LogicalFactor returns ArithmeticExpression
	 *     Relation returns ArithmeticExpression
	 *     Relation.Relation_1_0 returns ArithmeticExpression
	 *     ArithmeticExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (left=ArithmeticExpression_ArithmeticExpression_1_0 right=ArithmeticExpression2)
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getArithmeticExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getRightArithmeticExpression2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArraySubscripts returns ArraySubscripts
	 *
	 * Constraint:
	 *     (subscripts+=Subscript subscripts+=Subscript*)
	 */
	protected void sequence_ArraySubscripts(ISerializationContext context, ArraySubscripts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns Assert
	 *     Assert returns Assert
	 *
	 * Constraint:
	 *     (condition=Expression message=Expression level=AssertionLevel?)
	 */
	protected void sequence_Assert(ISerializationContext context, Assert semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphicalPrimitive returns Bitmap
	 *     Bitmap returns Bitmap
	 *
	 * Constraint:
	 *     (name='Bitmap' args+=GraphicalPrimitiveArgs args+=GraphicalPrimitiveArgs*)
	 */
	protected void sequence_Bitmap(ISerializationContext context, Bitmap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns Choices
	 *     Choices returns Choices
	 *
	 * Constraint:
	 *     (types+=IDENT (values+='true' | values+='false') (types+=IDENT (values+='true' | values+='false'))*)
	 */
	protected void sequence_Choices(ISerializationContext context, Choices semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns ClassDefinition
	 *
	 * Constraint:
	 *     (encapsulated?='encapsulated'? classPrefixes=ClassPrefixes classSpecifier=ClassSpecifier)
	 */
	protected void sequence_ClassDefinition(ISerializationContext context, ClassDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassModification returns ClassModification
	 *
	 * Constraint:
	 *     argumentList=ArgumentList?
	 */
	protected void sequence_ClassModification(ISerializationContext context, ClassModification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassPrefixes returns ClassPrefixes
	 *
	 * Constraint:
	 *     (
	 *         partial?='partial'? 
	 *         (
	 *             class?='class' | 
	 *             model?='model' | 
	 *             (operator?='operator'? record?='record') | 
	 *             block?='block' | 
	 *             (expandable?='expandable'? connector?='connector') | 
	 *             type?='type' | 
	 *             package?='package' | 
	 *             (pure?='pure'? operator?='operator'? function?='function') | 
	 *             operator?='operator'
	 *         )
	 *     )
	 */
	protected void sequence_ClassPrefixes(ISerializationContext context, ClassPrefixes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Color returns Color
	 *     GraphicalPrimitiveArgs returns Color
	 *
	 * Constraint:
	 *     (r=UNSIGNED_INTEGER g=UNSIGNED_INTEGER b=UNSIGNED_INTEGER)
	 */
	protected void sequence_Color(ISerializationContext context, Color semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.COLOR__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.COLOR__R));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.COLOR__G) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.COLOR__G));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.COLOR__B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.COLOR__B));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorAccess().getRUNSIGNED_INTEGERTerminalRuleCall_3_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getColorAccess().getGUNSIGNED_INTEGERTerminalRuleCall_5_0(), semanticObject.getG());
		feeder.accept(grammarAccess.getColorAccess().getBUNSIGNED_INTEGERTerminalRuleCall_7_0(), semanticObject.getB());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     (stringComment=StringComment annotation=Annotation?)
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentClause1 returns ComponentClause1
	 *
	 * Constraint:
	 *     (typePrefix=TypePrefix typeSpecifier=TypeSpecifier componentDeclaration=ComponentDeclaration1)
	 */
	protected void sequence_ComponentClause1(ISerializationContext context, ComponentClause1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.COMPONENT_CLAUSE1__TYPE_PREFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.COMPONENT_CLAUSE1__TYPE_PREFIX));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.COMPONENT_CLAUSE1__TYPE_SPECIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.COMPONENT_CLAUSE1__TYPE_SPECIFIER));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.COMPONENT_CLAUSE1__COMPONENT_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.COMPONENT_CLAUSE1__COMPONENT_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentClause1Access().getTypePrefixTypePrefixParserRuleCall_0_0(), semanticObject.getTypePrefix());
		feeder.accept(grammarAccess.getComponentClause1Access().getTypeSpecifierTypeSpecifierParserRuleCall_1_0(), semanticObject.getTypeSpecifier());
		feeder.accept(grammarAccess.getComponentClause1Access().getComponentDeclarationComponentDeclaration1ParserRuleCall_2_0(), semanticObject.getComponentDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentClause returns ComponentClause
	 *
	 * Constraint:
	 *     (typePrefix=TypePrefix typeSpec=TypeSpecifier arraySubscripts=ArraySubscripts? componentList=ComponentList)
	 */
	protected void sequence_ComponentClause(ISerializationContext context, ComponentClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDeclaration1 returns Declaration
	 *
	 * Constraint:
	 *     (name=IDENT arraySubscripts=ArraySubscripts? modification=Modification? comment=Comment?)
	 */
	protected void sequence_ComponentDeclaration1_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDeclaration returns ComponentDeclaration
	 *
	 * Constraint:
	 *     (declaration=Declaration conditionAttribute=ConditionAttribute? comment=StringComment? annotation=Annotation?)
	 */
	protected void sequence_ComponentDeclaration(ISerializationContext context, ComponentDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentList returns ComponentList
	 *
	 * Constraint:
	 *     (components+=ComponentDeclaration components+=ComponentDeclaration*)
	 */
	protected void sequence_ComponentList(ISerializationContext context, ComponentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns ComponentReference
	 *     LogicalExpression.LogicalExpression_1_0 returns ComponentReference
	 *     LogicalTerm returns ComponentReference
	 *     LogicalTerm.LogicalTerm_1_0 returns ComponentReference
	 *     LogicalFactor returns ComponentReference
	 *     Relation returns ComponentReference
	 *     Relation.Relation_1_0 returns ComponentReference
	 *     ArithmeticExpression returns ComponentReference
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns ComponentReference
	 *     ArithmeticExpression2 returns ComponentReference
	 *     ArithmeticExpression2.ArithmeticExpression2_1_0 returns ComponentReference
	 *     ArithmeticExpressionUnary returns ComponentReference
	 *     Term returns ComponentReference
	 *     Term.Term_1_0 returns ComponentReference
	 *     Factor returns ComponentReference
	 *     Factor.Factor_1_0 returns ComponentReference
	 *     Primary returns ComponentReference
	 *     ComponentReference returns ComponentReference
	 *
	 * Constraint:
	 *     (subs+=ArraySubscripts? (id+=IDENT subs+=ArraySubscripts?)*)
	 */
	protected void sequence_ComponentReference(ISerializationContext context, ComponentReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (
	 *         elementList=ElementList 
	 *         (elementListPublic+=ElementList | elementListProtected+=ElementList | equationSections+=EquationSection | algorithmSections+=AlgorithmSection)* 
	 *         LanguageSpecification=LanguageSpecification? 
	 *         annotation=Annotation?
	 *     )
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionAttribute returns ConditionAttribute
	 *
	 * Constraint:
	 *     condition=Expression
	 */
	protected void sequence_ConditionAttribute(ISerializationContext context, ConditionAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.CONDITION_ATTRIBUTE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.CONDITION_ATTRIBUTE__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAttributeAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConnectClause returns ConnectClause
	 *
	 * Constraint:
	 *     (node1=ComponentReference node2=ComponentReference annotation=Annotation?)
	 */
	protected void sequence_ConnectClause(ISerializationContext context, ConnectClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstrainingClause returns ConstrainingClause
	 *
	 * Constraint:
	 *     (name=Name classModification=ClassModification?)
	 */
	protected void sequence_ConstrainingClause(ISerializationContext context, ConstrainingClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CoordinateSpecification returns CoordinateSpecification
	 *
	 * Constraint:
	 *     (args+=CoordinateSpecificationArgs args+=CoordinateSpecificationArgs*)
	 */
	protected void sequence_CoordinateSpecification(ISerializationContext context, CoordinateSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (name=IDENT arraySubscripts=ArraySubscripts? modification=Modification?)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns DefComponentName
	 *     DefComponentName returns DefComponentName
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_DefComponentName(ISerializationContext context, DefComponentName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.DEF_COMPONENT_NAME__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.DEF_COMPONENT_NAME__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefComponentNameAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassSpecifier returns DerClassSpecifier
	 *     DerClassSpecifier returns DerClassSpecifier
	 *
	 * Constraint:
	 *     (id=IDENT name=Name comment=Comment?)
	 */
	protected void sequence_DerClassSpecifier(ISerializationContext context, DerClassSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns Dialog
	 *     Dialog returns Dialog
	 *
	 * Constraint:
	 *     (name='Dialog' args+=DialogArg args+=DialogArg*)
	 */
	protected void sequence_Dialog(ISerializationContext context, Dialog semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns ElementList
	 *
	 * Constraint:
	 *     elements+=Element*
	 */
	protected void sequence_ElementList(ISerializationContext context, ElementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns ElementModificationOrReplaceable
	 *     ElementModificationOrReplaceable returns ElementModificationOrReplaceable
	 *
	 * Constraint:
	 *     (each?='each'? final?='final'? (elementModOrRep=ElementModification | elementModOrRep=ElementReplaceable))
	 */
	protected void sequence_ElementModificationOrReplaceable(ISerializationContext context, ElementModificationOrReplaceable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementModification returns ElementModification
	 *
	 * Constraint:
	 *     (name=Name modification=Modification? stringComment=StringComment?)
	 */
	protected void sequence_ElementModification(ISerializationContext context, ElementModification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns ElementRedeclaration
	 *     ElementRedeclaration returns ElementRedeclaration
	 *
	 * Constraint:
	 *     (
	 *         redeclare?='redeclare' 
	 *         each?='each'? 
	 *         final?='final'? 
	 *         (classDefinition=ShortClassDefinition | componentClause=ComponentClause1 | element=ElementReplaceable)
	 *     )
	 */
	protected void sequence_ElementRedeclaration(ISerializationContext context, ElementRedeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementReplaceable returns ElementReplaceable
	 *
	 * Constraint:
	 *     (replaceable?='replaceable' (element=ShortClassDefinition | element=ComponentClause1) constraint=ConstrainingClause?)
	 */
	protected void sequence_ElementReplaceable(ISerializationContext context, ElementReplaceable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (
	 *         importClause=ImportClause | 
	 *         extendClause=ExtendClause | 
	 *         (
	 *             redeclare?='redeclare'? 
	 *             final?='final'? 
	 *             inner?='inner'? 
	 *             outer?='outer'? 
	 *             (class=ClassDefinition | comp=ComponentClause) 
	 *             (cc=ConstrainingClause comment=Comment?)?
	 *         )
	 *     )
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphicalPrimitive returns Ellipse
	 *     Ellipse returns Ellipse
	 *
	 * Constraint:
	 *     (name='Ellipse' args+=GraphicalPrimitiveArgs args+=GraphicalPrimitiveArgs*)
	 */
	protected void sequence_Ellipse(ISerializationContext context, Ellipse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DialogArg returns Enable
	 *     Enable returns Enable
	 *
	 * Constraint:
	 *     (value+=ComponentReference value+=ComponentReference*)
	 */
	protected void sequence_Enable(ISerializationContext context, Enable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumList returns EnumList
	 *
	 * Constraint:
	 *     (enumerationLiteral+=EnumerationLiteral enumerationLiteral+=EnumerationLiteral*)
	 */
	protected void sequence_EnumList(ISerializationContext context, EnumList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     comment=Comment
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ENUMERATION_LITERAL__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ENUMERATION_LITERAL__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationLiteralAccess().getCommentCommentParserRuleCall_1_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EquationFor returns EquationFor
	 *
	 * Constraint:
	 *     (iterators=ForIndices forEqs+=Equation*)
	 */
	protected void sequence_EquationFor(ISerializationContext context, EquationFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EquationIf returns EquationIf
	 *
	 * Constraint:
	 *     (ifExp=Expression ifEqs+=Equation* (elseifExp+=Expression elseIfEqs+=Equation*)* elseEqs+=Equation*)
	 */
	protected void sequence_EquationIf(ISerializationContext context, EquationIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EquationSection returns EquationSection
	 *
	 * Constraint:
	 *     (initial?='initial'? equation='equation' equations+=Equation*)
	 */
	protected void sequence_EquationSection(ISerializationContext context, EquationSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EquationWhen returns EquationWhen
	 *
	 * Constraint:
	 *     (whenExp=Expression whenEquations+=Equation* (exp+=Expression equationItem+=Equation*)*)
	 */
	protected void sequence_EquationWhen(ISerializationContext context, EquationWhen semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns Equation
	 *
	 * Constraint:
	 *     connection=ConnectClause
	 */
	protected void sequence_Equation(ISerializationContext context, Equation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.EQUATION__CONNECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.EQUATION__CONNECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquationAccess().getConnectionConnectClauseParserRuleCall_1_0(), semanticObject.getConnection());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns EquationFor
	 *
	 * Constraint:
	 *     (iterators=ForIndices forEqs+=Equation* comm=Comment?)
	 */
	protected void sequence_Equation_EquationFor(ISerializationContext context, EquationFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns EquationIf
	 *
	 * Constraint:
	 *     (ifExp=Expression ifEqs+=Equation* (elseifExp+=Expression elseIfEqs+=Equation*)* elseEqs+=Equation* comm=Comment?)
	 */
	protected void sequence_Equation_EquationIf(ISerializationContext context, EquationIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns EquationWhen
	 *
	 * Constraint:
	 *     (whenExp=Expression whenEquations+=Equation* (exp+=Expression equationItem+=Equation*)* comm=Comment?)
	 */
	protected void sequence_Equation_EquationWhen(ISerializationContext context, EquationWhen semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns Expression
	 *
	 * Constraint:
	 *     (start=LogicalExpression (step=LogicalExpression stop=LogicalExpression?)? equation=Expression? comm=Comment?)
	 */
	protected void sequence_Equation_SimpleExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExperimentOption returns ExperimentOption
	 *
	 * Constraint:
	 *     (start=UNSIGNED_NUMBER | stop=UNSIGNED_NUMBER | step=UNSIGNED_NUMBER | tol=UNSIGNED_NUMBER)
	 */
	protected void sequence_ExperimentOption(ISerializationContext context, ExperimentOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprExpressionList returns ExprExpressionList
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression*)
	 */
	protected void sequence_ExprExpressionList(ISerializationContext context, ExprExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Subscript returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (if=Expression then=Expression (elseif+=Expression elseifthen+=Expression)* else=Expression) | 
	 *         (start=LogicalExpression (step=LogicalExpression stop=LogicalExpression?)?)
	 *     )
	 */
	protected void sequence_Expression_SimpleExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendClause returns ExtendClause
	 *
	 * Constraint:
	 *     (name=Name classModification=ClassModification? annotation=Annotation?)
	 */
	protected void sequence_ExtendClause(ISerializationContext context, ExtendClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CoordinateSpecificationArgs returns Extent
	 *     Extent returns Extent
	 *     TransformationArg returns Extent
	 *     GraphicalPrimitiveArgs returns Extent
	 *
	 * Constraint:
	 *     (p1=Point p2=Point)
	 */
	protected void sequence_Extent(ISerializationContext context, Extent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.EXTENT__P1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.EXTENT__P1));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.EXTENT__P2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.EXTENT__P2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtentAccess().getP1PointParserRuleCall_3_0(), semanticObject.getP1());
		feeder.accept(grammarAccess.getExtentAccess().getP2PointParserRuleCall_5_0(), semanticObject.getP2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns Factor
	 *     LogicalExpression.LogicalExpression_1_0 returns Factor
	 *     LogicalTerm returns Factor
	 *     LogicalTerm.LogicalTerm_1_0 returns Factor
	 *     LogicalFactor returns Factor
	 *     Relation returns Factor
	 *     Relation.Relation_1_0 returns Factor
	 *     ArithmeticExpression returns Factor
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns Factor
	 *     ArithmeticExpression2 returns Factor
	 *     ArithmeticExpression2.ArithmeticExpression2_1_0 returns Factor
	 *     ArithmeticExpressionUnary returns Factor
	 *     Term returns Factor
	 *     Term.Term_1_0 returns Factor
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     (left=Factor_Factor_1_0 right=Primary)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.FACTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.FACTOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.FACTOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.FACTOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getFactorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForIndex returns ForIndex
	 *
	 * Constraint:
	 *     (id=IDENT expression=Expression)
	 */
	protected void sequence_ForIndex(ISerializationContext context, ForIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.FOR_INDEX__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.FOR_INDEX__ID));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.FOR_INDEX__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.FOR_INDEX__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForIndexAccess().getIdIDENTTerminalRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getForIndexAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForIndices returns ForIndices
	 *
	 * Constraint:
	 *     (forIndex+=ForIndex forIndex+=ForIndex*)
	 */
	protected void sequence_ForIndices(ISerializationContext context, ForIndices semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionArgument returns FunctionArgument
	 *
	 * Constraint:
	 *     ((name=Name namedArguments=NamedArguments?) | expression=Expression)
	 */
	protected void sequence_FunctionArgument(ISerializationContext context, FunctionArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionArguments returns FunctionArguments
	 *
	 * Constraint:
	 *     ((functionArgument=FunctionArgument (args+=FunctionArguments | forIndices+=ForIndices)?) | namedArguments=NamedArguments)
	 */
	protected void sequence_FunctionArguments(ISerializationContext context, FunctionArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArgs returns FunctionCallArgs
	 *
	 * Constraint:
	 *     functionArgs=FunctionArguments?
	 */
	protected void sequence_FunctionCallArgs(ISerializationContext context, FunctionCallArgs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphicalPrimitiveArgs returns GraphicalPrimitiveArgs
	 *
	 * Constraint:
	 *     ((points+=Point points+=Point*) | str=STRING | fileName=STRING | imageSource=STRING | fillPattern=FillPattern)
	 */
	protected void sequence_GraphicalPrimitiveArgs(ISerializationContext context, GraphicalPrimitiveArgs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Graphics returns Graphics
	 *
	 * Constraint:
	 *     (primitive+=GraphicalPrimitive primitive+=GraphicalPrimitive*)
	 */
	protected void sequence_Graphics(ISerializationContext context, Graphics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CoordinateSpecificationArgs returns Grid
	 *     Grid returns Grid
	 *
	 * Constraint:
	 *     value=Point
	 */
	protected void sequence_Grid(ISerializationContext context, Grid semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.GRID__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.GRID__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGridAccess().getValuePointParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DialogArg returns Group
	 *     Group returns Group
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.GROUP__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.GROUP__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportClause returns ImportClause
	 *
	 * Constraint:
	 *     (((id=IDENT name=Name) | (name=Name importList=ImportList?)) comment=Comment?)
	 */
	protected void sequence_ImportClause(ISerializationContext context, ImportClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportList returns ImportList
	 *
	 * Constraint:
	 *     (id+=IDENT id+=IDENT*)
	 */
	protected void sequence_ImportList(ISerializationContext context, ImportList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CoordinateSpecificationArgs returns InitialScale
	 *     InitialScale returns InitialScale
	 *
	 * Constraint:
	 *     value=UNSIGNED_NUMBER
	 */
	protected void sequence_InitialScale(ISerializationContext context, InitialScale semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.INITIAL_SCALE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.INITIAL_SCALE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialScaleAccess().getValueUNSIGNED_NUMBERTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns LayerDiagram
	 *     AnnotationLayer returns LayerDiagram
	 *     LayerDiagram returns LayerDiagram
	 *
	 * Constraint:
	 *     (coordinateSystem=CoordinateSpecification? graphics=Graphics?)
	 */
	protected void sequence_LayerDiagram(ISerializationContext context, LayerDiagram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns LayerIcon
	 *     AnnotationLayer returns LayerIcon
	 *     LayerIcon returns LayerIcon
	 *
	 * Constraint:
	 *     (coordinateSystem=CoordinateSpecification? graphics=Graphics)
	 */
	protected void sequence_LayerIcon(ISerializationContext context, LayerIcon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns Line
	 *     GraphicalPrimitive returns Line
	 *     Line returns Line
	 *
	 * Constraint:
	 *     (name='Line' args+=GraphicalPrimitiveArgs args+=GraphicalPrimitiveArgs*)
	 */
	protected void sequence_Line(ISerializationContext context, Line semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns LogicalExpression
	 *     LogicalExpression.LogicalExpression_1_0 returns LogicalExpression
	 *
	 * Constraint:
	 *     (left=LogicalExpression_LogicalExpression_1_0 right+=LogicalTerm)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns LogicalTerm
	 *     LogicalExpression.LogicalExpression_1_0 returns LogicalTerm
	 *     LogicalTerm returns LogicalTerm
	 *     LogicalTerm.LogicalTerm_1_0 returns LogicalTerm
	 *
	 * Constraint:
	 *     (left=LogicalTerm_LogicalTerm_1_0 right=LogicalFactor)
	 */
	protected void sequence_LogicalTerm(ISerializationContext context, LogicalTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.LOGICAL_TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.LOGICAL_TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.LOGICAL_TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.LOGICAL_TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalTermAccess().getLogicalTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalTermAccess().getRightLogicalFactorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassSpecifier returns LongClassSpecifier
	 *     LongClassSpecifier returns LongClassSpecifier
	 *
	 * Constraint:
	 *     (
	 *         (name=IDENT sringComment=StringComment? composition=Composition nameEnd=IDENT) | 
	 *         (
	 *             extends=ExtendClause 
	 *             name=IDENT 
	 *             classModification=ClassModification? 
	 *             sringComment=StringComment? 
	 *             composition=Composition 
	 *             nameEnd=IDENT
	 *         )
	 *     )
	 */
	protected void sequence_LongClassSpecifier(ISerializationContext context, LongClassSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modification returns Modification
	 *
	 * Constraint:
	 *     ((classModification=ClassModification expression=Expression?) | expression=Expression | expression=Expression)
	 */
	protected void sequence_Modification(ISerializationContext context, Modification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     id+=IDENT*
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedArgument returns NamedArgument
	 *
	 * Constraint:
	 *     (name=IDENT functionArgument=FunctionArgument)
	 */
	protected void sequence_NamedArgument(ISerializationContext context, NamedArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.NAMED_ARGUMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.NAMED_ARGUMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.NAMED_ARGUMENT__FUNCTION_ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.NAMED_ARGUMENT__FUNCTION_ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedArgumentAccess().getNameIDENTTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedArgumentAccess().getFunctionArgumentFunctionArgumentParserRuleCall_2_0(), semanticObject.getFunctionArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedArguments returns NamedArguments
	 *
	 * Constraint:
	 *     (namedArgument+=NamedArgument namedArguments=NamedArguments?)
	 */
	protected void sequence_NamedArguments(ISerializationContext context, NamedArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformationArg returns Origin
	 *     Origin returns Origin
	 *     GraphicalPrimitiveArgs returns Origin
	 *
	 * Constraint:
	 *     point=Point
	 */
	protected void sequence_Origin(ISerializationContext context, Origin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ORIGIN__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ORIGIN__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOriginAccess().getPointPointParserRuleCall_2_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns OutputExpresionList
	 *     LogicalExpression.LogicalExpression_1_0 returns OutputExpresionList
	 *     LogicalTerm returns OutputExpresionList
	 *     LogicalTerm.LogicalTerm_1_0 returns OutputExpresionList
	 *     LogicalFactor returns OutputExpresionList
	 *     Relation returns OutputExpresionList
	 *     Relation.Relation_1_0 returns OutputExpresionList
	 *     ArithmeticExpression returns OutputExpresionList
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns OutputExpresionList
	 *     ArithmeticExpression2 returns OutputExpresionList
	 *     ArithmeticExpression2.ArithmeticExpression2_1_0 returns OutputExpresionList
	 *     ArithmeticExpressionUnary returns OutputExpresionList
	 *     Term returns OutputExpresionList
	 *     Term.Term_1_0 returns OutputExpresionList
	 *     Factor returns OutputExpresionList
	 *     Factor.Factor_1_0 returns OutputExpresionList
	 *     Primary returns OutputExpresionList
	 *     OutputExpressionList returns OutputExpresionList
	 *
	 * Constraint:
	 *     (expressions+=Expression? expressions+=Expression*)
	 */
	protected void sequence_OutputExpressionList(ISerializationContext context, OutputExpresionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArg returns Placement
	 *     Placement returns Placement
	 *
	 * Constraint:
	 *     (name='Placement' args+=PlacementArg args+=PlacementArg*)
	 */
	protected void sequence_Placement(ISerializationContext context, Placement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     (x=num y=num)
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.POINT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.POINT__X));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.POINT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.POINT__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAccess().getXNumParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getPointAccess().getYNumParserRuleCall_3_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GraphicalPrimitive returns Polygon
	 *     Polygon returns Polygon
	 *
	 * Constraint:
	 *     (name='Polygon' args+=GraphicalPrimitiveArgs args+=GraphicalPrimitiveArgs*)
	 */
	protected void sequence_Polygon(ISerializationContext context, Polygon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CoordinateSpecificationArgs returns PreserveAR
	 *     PreserveAR returns PreserveAR
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_PreserveAR(ISerializationContext context, PreserveAR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression2 returns Expression
	 *     ArithmeticExpression2.ArithmeticExpression2_1_0 returns Expression
	 *     Term returns Expression
	 *     Term.Term_1_0 returns Expression
	 *     Factor returns Expression
	 *     Factor.Factor_1_0 returns Expression
	 *     Primary returns Expression
	 *
	 * Constraint:
	 *     ((list+=ExprExpressionList list+=ExprExpressionList*) | fa=FunctionArguments)
	 */
	protected void sequence_Primary(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns Primary
	 *     LogicalExpression.LogicalExpression_1_0 returns Primary
	 *     LogicalTerm returns Primary
	 *     LogicalTerm.LogicalTerm_1_0 returns Primary
	 *     LogicalFactor returns Primary
	 *     Relation returns Primary
	 *     Relation.Relation_1_0 returns Primary
	 *     ArithmeticExpression returns Primary
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns Primary
	 *     ArithmeticExpression2 returns Primary
	 *     ArithmeticExpression2.ArithmeticExpression2_1_0 returns Primary
	 *     ArithmeticExpressionUnary returns Primary
	 *     Term returns Primary
	 *     Term.Term_1_0 returns Primary
	 *     Factor returns Primary
	 *     Factor.Factor_1_0 returns Primary
	 *     Primary returns Primary
	 *
	 * Constraint:
	 *     (name=Name? fca=FunctionCallArgs)?
	 */
	protected void sequence_Primary(ISerializationContext context, Primary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=Name? classes+=ClassDefinition*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Radius returns Radius
	 *     GraphicalPrimitiveArgs returns Radius
	 *
	 * Constraint:
	 *     {Radius}
	 */
	protected void sequence_Radius(ISerializationContext context, Radius semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphicalPrimitive returns Rectangle
	 *     Rectangle returns Rectangle
	 *
	 * Constraint:
	 *     (name='Rectangle' args+=GraphicalPrimitiveArgs args+=GraphicalPrimitiveArgs*)
	 */
	protected void sequence_Rectangle(ISerializationContext context, Rectangle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns Relation
	 *     LogicalExpression.LogicalExpression_1_0 returns Relation
	 *     LogicalTerm returns Relation
	 *     LogicalTerm.LogicalTerm_1_0 returns Relation
	 *     LogicalFactor returns Relation
	 *     Relation returns Relation
	 *
	 * Constraint:
	 *     (left=Relation_Relation_1_0 right=ArithmeticExpression)
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.RELATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.RELATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.RELATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.RELATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationAccess().getRelationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationAccess().getRightArithmeticExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransformationArg returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     (name='rotation' value=Expression)
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ROTATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ROTATION__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.ROTATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.ROTATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotationAccess().getNameRotationKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRotationAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ShortClassDefinition returns ShortClassDefinition
	 *
	 * Constraint:
	 *     (classPrefixes=ClassPrefixes classSpecifier=ShortClassSpecifier)
	 */
	protected void sequence_ShortClassDefinition(ISerializationContext context, ShortClassDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.SHORT_CLASS_DEFINITION__CLASS_PREFIXES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.SHORT_CLASS_DEFINITION__CLASS_PREFIXES));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.SHORT_CLASS_DEFINITION__CLASS_SPECIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.SHORT_CLASS_DEFINITION__CLASS_SPECIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortClassDefinitionAccess().getClassPrefixesClassPrefixesParserRuleCall_0_0(), semanticObject.getClassPrefixes());
		feeder.accept(grammarAccess.getShortClassDefinitionAccess().getClassSpecifierShortClassSpecifierParserRuleCall_1_0(), semanticObject.getClassSpecifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassSpecifier returns ShortClassSpecifier
	 *     ShortClassSpecifier returns ShortClassSpecifier
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name=IDENT 
	 *             basePrefix=BasePrefix 
	 *             instanceName=Name 
	 *             arraySubscripts=ArraySubscripts? 
	 *             classModification=ClassModification? 
	 *             comment=Comment?
	 *         ) | 
	 *         (name=IDENT enumList=EnumList? comment=Comment?)
	 *     )
	 */
	protected void sequence_ShortClassSpecifier(ISerializationContext context, ShortClassSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Expression
	 *
	 * Constraint:
	 *     (start=LogicalExpression (step=LogicalExpression stop=LogicalExpression?)?)
	 */
	protected void sequence_SimpleExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Smooth returns Smooth
	 *     GraphicalPrimitiveArgs returns Smooth
	 *
	 * Constraint:
	 *     value=SmoothEnum
	 */
	protected void sequence_Smooth(ISerializationContext context, Smooth semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.SMOOTH__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.SMOOTH__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSmoothAccess().getValueSmoothEnumEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementFor returns StatementFor
	 *
	 * Constraint:
	 *     (iterators=ForIndices forEqs+=Statement*)
	 */
	protected void sequence_StatementFor(ISerializationContext context, StatementFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementIf returns StatementIf
	 *
	 * Constraint:
	 *     (ifExp=Expression ifEqs+=Statement* (elseifExp+=Expression elseIfEqs+=Statement*)* elseEqs+=Statement*)
	 */
	protected void sequence_StatementIf(ISerializationContext context, StatementIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementWhen returns StatementWhen
	 *
	 * Constraint:
	 *     (whenExp=Expression whenEquations+=Statement* (exp+=Expression equationItem+=Statement*)*)
	 */
	protected void sequence_StatementWhen(ISerializationContext context, StatementWhen semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementWhile returns StatementWhile
	 *
	 * Constraint:
	 *     (boolExpr=Expression stat+=Statement*)
	 */
	protected void sequence_StatementWhile(ISerializationContext context, StatementWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (component=ComponentReference (expression=Expression | fca=FunctionCallArgs)) | 
	 *             (expression=OutputExpressionList component=ComponentReference fca=FunctionCallArgs)
	 *         )? 
	 *         comm=Comment
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementFor
	 *
	 * Constraint:
	 *     (iterators=ForIndices forEqs+=Statement* comm=Comment)
	 */
	protected void sequence_Statement_StatementFor(ISerializationContext context, StatementFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementIf
	 *
	 * Constraint:
	 *     (ifExp=Expression ifEqs+=Statement* (elseifExp+=Expression elseIfEqs+=Statement*)* elseEqs+=Statement* comm=Comment)
	 */
	protected void sequence_Statement_StatementIf(ISerializationContext context, StatementIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementWhen
	 *
	 * Constraint:
	 *     (whenExp=Expression whenEquations+=Statement* (exp+=Expression equationItem+=Statement*)* comm=Comment)
	 */
	protected void sequence_Statement_StatementWhen(ISerializationContext context, StatementWhen semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementWhile
	 *
	 * Constraint:
	 *     (boolExpr=Expression stat+=Statement* comm=Comment)
	 */
	protected void sequence_Statement_StatementWhile(ISerializationContext context, StatementWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringComment returns StringComment
	 *
	 * Constraint:
	 *     str+=STRING*
	 */
	protected void sequence_StringComment(ISerializationContext context, StringComment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Subscript returns Subscript
	 *
	 * Constraint:
	 *     {Subscript}
	 */
	protected void sequence_Subscript(ISerializationContext context, Subscript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DialogArg returns Tab
	 *     Tab returns Tab
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Tab(ISerializationContext context, Tab semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.TAB__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.TAB__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTabAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns Term
	 *     LogicalExpression.LogicalExpression_1_0 returns Term
	 *     LogicalTerm returns Term
	 *     LogicalTerm.LogicalTerm_1_0 returns Term
	 *     LogicalFactor returns Term
	 *     Relation returns Term
	 *     Relation.Relation_1_0 returns Term
	 *     ArithmeticExpression returns Term
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns Term
	 *     ArithmeticExpression2 returns Term
	 *     ArithmeticExpression2.ArithmeticExpression2_1_0 returns Term
	 *     ArithmeticExpressionUnary returns Term
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (left=Term_Term_1_0 right=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getRightFactorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GraphicalPrimitive returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     (name='Text' args+=GraphicalPrimitiveArgs args+=GraphicalPrimitiveArgs*)
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thickness returns Thickness
	 *     GraphicalPrimitiveArgs returns Thickness
	 *
	 * Constraint:
	 *     value=UNSIGNED_NUMBER
	 */
	protected void sequence_Thickness(ISerializationContext context, Thickness semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.THICKNESS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.THICKNESS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThicknessAccess().getValueUNSIGNED_NUMBERTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PlacementArg returns Transformation
	 *     Transformation returns Transformation
	 *
	 * Constraint:
	 *     ((name='transformation' | name='iconTransformation') args+=TransformationArg args+=TransformationArg*)
	 */
	protected void sequence_Transformation(ISerializationContext context, Transformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasePrefix returns TypePrefix
	 *     TypePrefix returns TypePrefix
	 *
	 * Constraint:
	 *     (
	 *         (flow?='flow' | stream?='stream')? 
	 *         (constant?='constant' | parameter?='parameter' | discrete?='discrete')? 
	 *         (input?='input' | output?='output')?
	 *     )
	 */
	protected void sequence_TypePrefix(ISerializationContext context, TypePrefix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns TypeSpecifier
	 *
	 * Constraint:
	 *     name=Name
	 */
	protected void sequence_TypeSpecifier(ISerializationContext context, TypeSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelicaMoPackage.Literals.TYPE_SPECIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelicaMoPackage.Literals.TYPE_SPECIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeSpecifierAccess().getNameNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PlacementArg returns Visible
	 *     Visible returns Visible
	 *     GraphicalPrimitiveArgs returns Visible
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Visible(ISerializationContext context, Visible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
